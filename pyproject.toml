[build-system]
requires = ["uv_build>=0.9.6,<0.10.0"]
build-backend = "uv_build"

[project]
name = "aclaf"
version = "0.1.0"
authors = [{ name = "Tony Burns", email = "tony@tonyburns.net" }]
description = "A command line application framework."
readme = "README.md"
requires-python = ">=3.10"
classifiers = [
  "Development Status :: 3 - Alpha",
  "Environment :: Console",
  "Intended Audience :: Developers",
  "License :: OSI Approved :: MIT License",
  "Operating System :: OS Independent",
  "Programming Language :: Python",
  "Programming Language :: Python :: 3",
  "Programming Language :: Python :: 3 :: Only",
  "Programming Language :: Python :: 3.10",
  "Programming Language :: Python :: 3.11",
  "Programming Language :: Python :: 3.12",
  "Programming Language :: Python :: 3.13",
  "Programming Language :: Python :: 3.14",
  "Topic :: Software Development :: Libraries :: Python Modules",
  "Topic :: Terminals",
  "Topic :: Utilities",
  "Typing :: Typed",
]
dependencies = [
  "annotated-types>=0.7.0",
  "typing-extensions>=4.15.0",
  "typing-inspection>=0.4.2",
]

[project.optional-dependencies]
rich = ["rich>=14.2.0"]
loguru = ["loguru>=0.7.3"]
structlog = ["structlog>=25.5.0"]

[dependency-groups]
dev = [
  "basedpyright>=1.32.1",
  "codespell>=2.4.1",
  "commitizen>=4.9.1",
  "djlint>=1.36.4",
  "hypothesis>=6.147.0",
  "import-linter>=2.6",
  "mkdocs-git-authors-plugin>=0.10.0",
  "mkdocs-git-revision-date-localized-plugin>=1.5.0",
  "mkdocs-glightbox>=0.5.2",
  "mkdocs-material>=9.6.23",
  "mkdocs-rss-plugin>=1.17.4",
  "mkdocstrings[python]>=0.30.1",
  "prek>=0.2.12",
  "py-spy>=0.4.1",
  "pydeps>=3.0.1",
  "pytest-asyncio>=1.2.0",
  "pytest-benchmark>=5.2.2",
  "pytest-cov>=7.0.0",
  "pytest-mock>=3.15.1",
  "pytest>=8.4.2",
  "ruff>=0.14.3",
  "vulture>=2.14",
  "yamllint>=1.37.1",
]

[tool.basedpyright]
include = ["src", "tests"]

[tool.codespell]
skip = "pnpm-lock.yaml,uv.lock,htmlcov,site,tmp"
ignore-words-list = "nd,ue,metacharacter,subcmd,cna,metadataa,metadatab,metadatac"

[tool.commitizen]
name = "cz_conventional_commits"
version_provider = "pep621"
tag_format = "v$version"
major_version_zero = true
update_changelog_on_bump = true
pre_bump_hooks = ["uv sync --all-packages --all-groups --all-extras"]

[tool.pytest.ini_options]
addopts = [
  "--import-mode=importlib",
  "--tb",
  "short",
  "--ignore=tests/benchmarks",
]
pythonpath = ["src"]
asyncio_mode = "auto"
filterwarnings = ["error"]
testpaths = ["tests"]
xfail_strict = true
markers = [
  "security: Security-focused tests for injection and validation (deselect with '-m \"not security\"')",
]

[tool.coverage.run]
branch = true
source = ["src/aclaf"]
relative_files = true
omit = ["tests/*", "**/__pycache__/*", "**/site-packages/*"]

[tool.coverage.report]
exclude_lines = [
  "pragma: no cover",
  "def __repr__",
  "raise AssertionError",
  "raise NotImplementedError",
  "if __name__ == .__main__.:",
  "if TYPE_CHECKING:",
  "@abstractmethod",
  "@abc.abstractmethod",
]
precision = 2
show_missing = true
skip_covered = false

[tool.coverage.xml]
output = "coverage.xml"

[tool.coverage.html]
directory = "htmlcov"

[tool.hypothesis]
# Save failing examples to local database for reproducibility
database = ".hypothesis/examples"
# Show more detailed output during test runs
verbosity = "verbose"
# Default number of examples to test per property
max_examples = 100

[tool.importlinter]
root_package = "aclaf"

# Architectural layer contracts
# ==============================
# These contracts enforce the architectural boundaries between different layers
# of the aclaf framework. The architecture follows a layered approach where lower
# layers provide foundational functionality and higher layers build on them.
#
# Layer hierarchy (from lowest to highest):
#   0. Utilities: _internal (runtime type inspection utilities only)
#   1. Foundation: exceptions, protocols, types
#   2. Infrastructure: console, logging, parser
#   3. Core logic: conversion, validation, metadata
#   4. Runtime: execution, response
#   5. Registration: registration (mutable builders, uses _internal)
#   6. Application: _application (orchestration)
#
# _internal is a special utility layer that sits below foundation. It provides
# runtime type inspection utilities (wrapping typing-extensions, typing-inspection,
# annotated-types) and must remain completely independent of all aclaf modules.
# After the metadata refactoring, _internal only contains _inspect.py (runtime
# type inspection). Only conversion and registration layers should import from _internal.

[[tool.importlinter.contracts]]
name = "Parser must remain isolated from business logic"
type = "forbidden"
source_modules = ["aclaf.parser"]
forbidden_modules = [
  "aclaf.conversion",
  "aclaf.validation",
  "aclaf.metadata",
  "aclaf.execution",
  "aclaf.registration",
  "aclaf.response",
  "aclaf._application",
]
# Parser can import from: exceptions, protocols, types (allowed dependencies)

[[tool.importlinter.contracts]]
name = "Infrastructure layers must not import from business logic"
type = "forbidden"
source_modules = ["aclaf.console", "aclaf.logging"]
forbidden_modules = [
  "aclaf.parser",
  "aclaf.conversion",
  "aclaf.validation",
  "aclaf.metadata",
  "aclaf.execution",
  "aclaf.registration",
  "aclaf.response",
  "aclaf._application",
]

[[tool.importlinter.contracts]]
name = "Types layer must not import from parser"
type = "forbidden"
source_modules = ["aclaf.types"]
forbidden_modules = ["aclaf.parser"]
# Parser can import from types (correct dependency direction: types <- parser)

[[tool.importlinter.contracts]]
name = "Response layer must not import from registration or execution internals"
type = "forbidden"
source_modules = ["aclaf.response"]
forbidden_modules = [
  "aclaf.registration",
  "aclaf.execution",
  "aclaf.validation",
  "aclaf.conversion",
  "aclaf.metadata",
  "aclaf.parser",
]
# Response can import from: console, exceptions, protocols, types (allowed dependencies)

[[tool.importlinter.contracts]]
name = "Conversion layer must not import from higher layers"
type = "forbidden"
source_modules = ["aclaf.conversion"]
forbidden_modules = [
  "aclaf.validation",
  "aclaf.execution",
  "aclaf.registration",
  "aclaf.response",
  "aclaf._application",
]

[[tool.importlinter.contracts]]
name = "Validation layer must not import from higher layers"
type = "forbidden"
source_modules = ["aclaf.validation"]
forbidden_modules = [
  "aclaf.execution",
  "aclaf.registration",
  "aclaf.response",
  "aclaf._application",
]

[[tool.importlinter.contracts]]
name = "Metadata layer must not import from higher layers"
type = "forbidden"
source_modules = ["aclaf.metadata"]
forbidden_modules = [
  "aclaf.conversion",
  "aclaf.validation",
  "aclaf.execution",
  "aclaf.registration",
  "aclaf.response",
  "aclaf._application",
]
# Metadata provides command/parameter metadata extraction and manipulation utilities.
# It can import from foundation layers and parser, but must not import from conversion,
# validation, or higher layers to maintain clean architectural separation.

[[tool.importlinter.contracts]]
name = "Execution layer must not import from registration"
type = "forbidden"
source_modules = ["aclaf.execution"]
forbidden_modules = [
  "aclaf.registration", # Registration builds execution specs, not vice versa
  "aclaf._application",
]

[[tool.importlinter.contracts]]
name = "Foundation layers must be dependency-free"
type = "independence"
modules = ["aclaf.exceptions", "aclaf.protocols", "aclaf.types"]
# Types is now a foundation layer providing core type definitions used by parser and other layers.

[[tool.importlinter.contracts]]
name = "Internal utilities must not import from higher layers"
type = "forbidden"
source_modules = ["aclaf._internal"]
forbidden_modules = [
  "aclaf.parser",
  "aclaf.console",
  "aclaf.logging",
  "aclaf.conversion",
  "aclaf.validation",
  "aclaf.metadata",
  "aclaf.execution",
  "aclaf.registration",
  "aclaf.response",
  "aclaf._application",
]
# _internal provides runtime type inspection utilities (_inspect.py) and must remain
# completely independent of all aclaf modules. It can import from foundation layers
# (exceptions, protocols, types) for type annotations, but must not import from
# metadata, infrastructure, or higher layers. This keeps _internal minimal and
# prevents circular dependencies.

[[tool.importlinter.contracts]]
name = "Internal utilities should only be directly imported by conversion and registration"
type = "forbidden"
source_modules = [
  "aclaf.exceptions",
  "aclaf.protocols",
  "aclaf.types",
  "aclaf.parser",
  "aclaf.console",
  "aclaf.logging",
  "aclaf.validation",
  "aclaf.metadata",
  "aclaf.response",
]
forbidden_modules = ["aclaf._internal"]
# Only conversion and registration layers should directly import from _internal, as they
# need runtime type inspection. Other layers may depend on _internal transitively through
# conversion/registration, but should not import it directly. This prevents _internal
# from becoming a dumping ground for miscellaneous utilities.

[tool.ruff]
target-version = "py310"

[tool.ruff.format]
docstring-code-format = true

[tool.ruff.lint]
select = [
  "A",     # flake8-builtins
  "ARG",   # flake8-unused-arguments
  "ASYNC", # flake8-async
  "B",     # bugbear
  "BLE",   # flake8-blind-except
  "C4",    # flake8-comprehensions
  "D",     # pydocstyle
  "DTZ",   # flake8-datetimez
  "E",     # pycodestyle (error)
  "EM",    # flake8-errmsg
  "EXE",   # flake8-executable
  "F",     # pyflakes
  "FBT",   # flake8-boolean-trap
  "FURB",  # refurb
  "G",     # flake8-logging-format
  "I",     # isort
  "ICN",   # flake8-import-conventions
  "ISC",   # flake8-implicit-str-concat
  "LOG",   # flake8-logging
  "N",     # pep8-naming
  "PERF",  # Perflint
  "PGH",   # pygrep-hooks
  "PIE",   # flake8-pie
  "PL",    # pylint
  "PT",    # flake8-pytest-style
  "PTH",   # flake8-use-pathlib
  "PYI",   # flake8-pyi
  "RET",   # flake8-return
  "RUF",   # Ruff-specific rules
  "S",     # flake8-bandit
  "SIM",   # flake8-simplify
  "SLF",   # flake8-self
  "SLOT",  # flake8-slots
  "TC",    # flake8-type-checking
  "TD",    # flake8-todos
  "TID",   # flake8-tidy-imports
  "T10",   # flake8-debugger
  "T20",   # flake8-print
  "TRY",   # tryceratops
  "UP",    # pyupgrade
]
ignore = [
  "D100",  # Missing docstring in public module
  "D101",  # Missing docstring in public class
  "D102",  # Missing docstring in public method
  "D103",  # Missing docstring in public function
  "D104",  # Missing docstring in public package
  "D105",  # Missing docstring in magic method
  "D107",  # Missing docstring in __init__
  "TD003",
]
pydocstyle = { convention = "google" }

[tool.ruff.lint.isort]
combine-as-imports = true
extra-standard-library = ["typing_extensions"]
forced-separate = ["tests"]

[tool.ruff.lint.flake8-type-checking]
quote-annotations = true

[tool.ruff.lint.flake8-unused-arguments]
ignore-variadic-names = true

[tool.ruff.lint.per-file-ignores]
"**/__main__.py" = ["D100"]
"**/tests/**" = [
  "ARG001",
  "D",
  "PLR2004",
  "S101",
  "TC003",
] # TC003: Path is used at runtime in fixtures
"examples/**" = ["T201"] # Allow print in examples
"scripts/**" = ["T201"] # Allow print in scripts
"src/aclaf/validation/**" = [
  "ARG001",
] # Validators must match Protocol signature even if params unused

[tool.uv.sources]
aclaf = { workspace = true }
aclaf-cli = { workspace = true }

[tool.uv.workspace]
members = [".", "cli"]
